#!/usr/bin/perl -w
-













#
#
#		Perl Script auto generated by Perl Parser 1.0.1
#		Do not modify it by hands.
#
#		Dynamic HTML extractor ver. 1.0
#
#		Copyright (c) 2004, Fischer Dam.
#		weldan@21cn.com
#


#
# perl script head, use declare
#

use strict "vars";
use warnings;
use utf8;

use LogIt;

BEGIN
{
	my $nicetime = localtime($^T);
	LogIt( mINFO, "Script >>$0<< started at $nicetime." );
	LogIt( mINFO, "Script >>$0<< PID $$" );
}

END
{
	#&close_db if &is_db_connected;
	LogIt( mINFO, &disp_time( time - $^T ));
	my $nicetime = localtime(time);
	LogIt( mINFO, "Script >>$0<< stoped at $nicetime.\n" );
}

sub disp_time
{
	my $sec = shift;
	my $seconds = $sec % 60;
	my $minutes = (( $sec - $seconds ) / 60 ) % 60 ;
	my $hours   = ( $sec - $minutes*60 - $seconds ) / (60*60);

	my $str = "Script runs";
	$str .= " $hours hour" if( $hours );
	$str .= "s" if ( $hours > 1 );
	$str .= " $minutes minute" if ( $minutes );
	$str .= "s" if ( $minutes > 1 );
	$str .= " $seconds second" if ( $seconds );
	$str .= "s" if ( $seconds > 1 );

	return $str;
}

#
#	Function lib for perl script
#	create 9 Aug, 2004
#


#
#	Database process subroutine
#	Create by Fischer Dam, 10 Aug, 2004
#

use DBI;

# define database handler
my $dbh;
# define statement handler
my $sth;

# Connect database
sub connect_db
{

	my ( $driver, $dsn, $username, $passwd ) = @_;

	$dbh=DBI->connect( "dbi:$driver:$dsn", $username, $passwd );

	unless ( $dbh ) {
		LogIt ( 'mERROR', "can't open database: $DBI::errstr" );
		exit;
	}

	# disable autocommit in order to use transactions
	$dbh->{AutoCommit} = 0;	
	# disable error message output to stderr
	$dbh->{PrintError} = 0;

	LogIt 'mINFO', "Connect database OK!";
#	$dbh->trace( 2, "db_trace.txt" );

}


# Close database connection
sub close_db
{
	$sth->finish;
#	$dbh->disconnect;
	LogIt 'mINFO', "Close database connection.";
	undef $sth;
	undef $dbh;
}


# Check database connection status
sub is_db_connected
{

	return 0 unless $dbh;

	LogIt 'mINFO', "Check database connection status...";

	my $connected = $dbh->ping;

	unless( $connected ){
		LogIt 'mERROR', "Database connection lost!";
		return 0;
	}

	if( int( $connected ) ) {
		LogIt 'mINFO', "Database connection is alive.";
		return 1;
	} else {
		LogIt 'mWARN', "Ping not implemented by '" .
				$dbh->{Driver}->{Name} . "'.";
		return 2;
	}
}

# Insert a record to database
sub insert_db
{
	my $_date = shift;
	my $_type = shift;
	$_date = $dbh->quote( $_date );
	my $SQL = "INSERT INTO exchange (exdate,type) VALUES ($_date, $_type )";
	LogIt 'mINFO', $SQL;
	my $rows = $dbh->do( $SQL );
	unless ( defined $rows ) {
		LogIt 'mERROR', $dbh->errstr;
		return undef;
	}
	$dbh->commit();
}

# Check if Duplicate date type record exist
sub check_dup_date_type
{
	my $_date = shift;
	my $_type = shift;
	$_date = $dbh->quote( $_date );
	my $SQL = "SELECT COUNT(*) FROM exchange WHERE exdate = $_date and type = $_type";
	$sth = $dbh->prepare( $SQL );
	LogIt 'mERROR', $dbh->errstr unless( $sth );
	unless( $sth->execute( ) ) {
		LogIt 'mERROR', "Execute SQL:", $dbh->errstr;
		return -1;
	}
	my $count = $sth->fetchrow_array;
	$sth->finish;
	return $count;
}
	
# Update a record to database
sub update_db
{
	my $key;
	my $value;
	my $_date = shift;
	my $_type = shift;
	my @conditions;
	my %_statistic = @_;
	$_date = $dbh->quote( $_date );
	my $SQL = "UPDATE exchange SET ";
	while( ( $key, $value ) = each( %_statistic ) ){
		$value = 0 unless defined $value;
		push @conditions, "$key = $value";
	}
	$SQL .= join( ', ', @conditions ) .
			" WHERE exdate = $_date and type = $_type";
	LogIt 'mINFO', $SQL;
	my $rows = $dbh->do( $SQL );
	unless ( defined $rows ) {
		LogIt 'mERROR', $dbh->errstr;
		return undef;
	}
	$dbh->commit();
}

# Write record to database
sub write_db
{
	my $_date = shift;
	my $_type = shift;

	&insert_db( $_date, $_type )
	unless &check_dup_date_type( $_date, $_type ); 

	&update_db( $_date, $_type, @_ ) if( @_ );
}

use Time::Local;

sub date_1
{
	my ($date, $days) = @_;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = ();

	$year	= substr ($date, 0, 4);
	$mon	= substr ($date, 4, 2) - 1;
	$mday	= substr ($date, 6, 2);
	$days = 1 unless ($days);
	$sec = 24*60*60 * $days;

	my $time = timelocal (0, 0, 0, $mday, $mon, $year) - $sec;
	($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime($time);

	return sprintf ("%04d%02d%02d", $year+1900, $mon+1, $mday);
}

sub parse_file
{
my( $type, $year, $month, $date, $department, $total ) = ();
my $process_flag = 0;	# 0 - not ready, 1 - wait for total, 2 - process
my $file;
my $tmp_line = '';
my %chg_month = (
	'January'	=>	'01',
	'February'	=>	'02',
	'March'		=>	'03',
	'April'		=>	'04',
	'May'		=>	'05',
	'June'		=>	'06',
	'July'		=>	'07',
	'August'	=>	'08',
	'September'	=>	'09',
	'October'	=>	'10',
	'November'	=>	'11',
	'December'	=>	'12',
	'1月'		=>	'01',
	'2月'		=>	'02',
	'3月'		=>	'03',
	'4月'		=>	'04',
	'5月'		=>	'05',
	'6月'		=>	'06',
	'7月'		=>	'07',
	'8月'		=>	'08',
	'9月'		=>	'09',
	'10月'		=>	'10',
	'11月'		=>	'11',
	'12月'		=>	'12',
);
my %statistic = ();

	$file = $_[0];

	use Email::MIME;

	my	$message = do {
		local $/ = undef;	# unset line delimiter in order to load whole file
		open( my $fh, '<:encoding(utf8)', "../txt/$file" ) || die "Can't open ../txt/$file: $!\n";
		LogIt 'mINFO', "open $file for input";
		<$fh>;
	};

	my $email = Email::MIME->new($message);
	my $body = $email->body;

	#utf8::decode($body);
	Encode::_utf8_on($body);
	my @text = split /\n/, $body;
	LogIt 'mINFO', 'subject: ', $email->header('subject');
	my $lineno = 0;
	foreach( @text ){
		$lineno++;
		chomp;
		while( s/(.+)\s$/$1/ ) {};	# remove tail space
		$_ = $tmp_line . $_;
		if ( /^\S+$/ ) {		# joint two lines if necessary
			$tmp_line = $_;
		} else {
			$tmp_line = '';
		}
		next if( /^\s*$/ );		# bypass null row
#print "$_\n";
		last if( (/^TOTAL/ || /^总计/) && $process_flag == 2 );
		if(	/Item library    Item/ ||
			/馆藏所在图书馆    馆藏类型/	) {
			$process_flag = 1;
			next;			# must need here
		}
		if( $process_flag == 1 ) {	# check if ready
			if( / TOTAL/ || / 总计/ ){
				$process_flag = 2;
			}
			next;
		}
		if( $process_flag == 2 ) {	# ready for data
			/^(\S+)/;
			my $dept = $1;
			/(\d+)$/;
			my $value = $1;
			LogIt mERROR, "line $lineno: value $value has no dept" if not defined $dept;
			$statistic{$dept} = $value;
			next;
		}

		# 1 - 借阅；2 - 归还；3 - 续借
		if( /分馆借书量统计[-|_]每天/ || /分馆借书量统计[-|_]\d{4}/) {
			$type = 1;
		}
		if( /分馆还书量统计[-|_]每天/ || /分馆还书量统计[-|_]\d{4}/) {
			$type = 2;
		}
		if( /分馆续借量统计[-|_]每天/ || /分馆续借量统计[-|_]\d{4}/) {
			$type = 3;
		}
		if( /Produced \S+, (\d{4}) (\S+) (\d+)/ ){
			$year	= $1;
			$month	= $2;
			$date	= $3;
		}
		if( /产生的 +\S+, (\d{4})年(\d+月)(\d+)日/ ){
			$year	= $1;
			$month	= $2;
			$date	= $3;
		}
		if( /产生的\s+\S+, (\d{4}) (\d+月) (\d+)/ ){
			$year	= $1;
			$month	= $2;
			$date	= $3;
		}
#		LogIt 'mINFO', $_;
	}
	LogIt 'mERROR', "no year detected!" unless $year;
	LogIt 'mERROR', "no month detected!" unless $month;
	LogIt 'mERROR', "no date detected!" unless $date;

	$date = '0' . $date if( $date =~ /^\d$/ );
	$date = $year . $chg_month{$month} . $date;
	$date = &date_1($date);
#	print "$bypass $process_flag $type $date $file\n" if( $type );
	&fill_blank($date);
	&write_db( $date, $type, %statistic ) if( $type );
}

my %fill_blank_date=();

sub fill_blank
{
	my ($i, $j);

	my $_date = shift;
	my $_date_01 = sprintf('%6.6s01', $_date);
	$_date = "$_date_01";
	unless ($fill_blank_date{substr($_date_01,0,6)}){
		for ($i=0; $i<31; $i++) {
			next unless substr($_date_01,0,6) eq substr($_date,0,6);
			for ($j=1; $j<4; $j++) {
				&insert_db( $_date, $j )
				unless &check_dup_date_type( $_date, $j ); 
			}
			$_date = &date_1($_date, -1);
		}
		$dbh->commit();
	}
	$fill_blank_date{substr($_date_01,0,6)} = 1;
}

my $dir;
my $file_cnt = 0;
opendir( DIR, '../txt' ) || die "Can't open dir ../txt: $!\n";

use Win32::OLE;
Win32::OLE -> Option(CP => 65001);
#Win32::OLE -> Option(CP => Win32::OLE::CP_UTF8);

#my $dsn = 'driver=Microsoft Access Driver (*.mdb);dbq=';
my $dsn = 'Provider=Microsoft.Jet.OLEDB.4.0;Data Source=';
$dsn .= '../db/db_pku.mdb';
#&connect_db( 'ODBC', $dsn );
&connect_db( 'ADO', $dsn );

while( $dir = readdir(DIR)){
	next if( $dir =~ /^\./ );
	$file_cnt++;
#	print "$dir\n";
	&parse_file( $dir );
}

closedir DIR;
LogIt 'mINFO', "$file_cnt files scaned";
